/* automatically generated by rust-bindgen 0.64.0 */

pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const BLOSC2_VERSION_MAJOR: u32 = 2;
pub const BLOSC2_VERSION_MINOR: u32 = 8;
pub const BLOSC2_VERSION_RELEASE: u32 = 1;
pub const BLOSC2_VERSION_STRING: &[u8; 10usize] = b"2.8.1.dev\0";
pub const BLOSC2_VERSION_DATE: &[u8; 22usize] = b"$Date:: 2023-03-24 #$\0";
pub const BLOSC2_MAX_DIM: u32 = 8;
pub const BLOSC_BLOSCLZ_COMPNAME: &[u8; 8usize] = b"blosclz\0";
pub const BLOSC_LZ4_COMPNAME: &[u8; 4usize] = b"lz4\0";
pub const BLOSC_LZ4HC_COMPNAME: &[u8; 6usize] = b"lz4hc\0";
pub const BLOSC_ZLIB_COMPNAME: &[u8; 5usize] = b"zlib\0";
pub const BLOSC_ZSTD_COMPNAME: &[u8; 5usize] = b"zstd\0";
pub const BLOSC_BLOSCLZ_LIBNAME: &[u8; 8usize] = b"BloscLZ\0";
pub const BLOSC_LZ4_LIBNAME: &[u8; 4usize] = b"LZ4\0";
pub const BLOSC_ZLIB_LIBNAME: &[u8; 5usize] = b"Zlib\0";
pub const BLOSC_ZSTD_LIBNAME: &[u8; 5usize] = b"Zstd\0";
pub const BLOSC2_MAX_METALAYERS: u32 = 16;
pub const BLOSC2_METALAYER_NAME_MAXLEN: u32 = 31;
pub const BLOSC2_MAX_VLMETALAYERS: u32 = 8192;
pub const BLOSC2_VLMETALAYERS_NAME_MAXLEN: u32 = 31;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
impl Default for __atomic_wide_counter {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_slist {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutexattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_condattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlock_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_rwlockattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrier_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_barrierattr_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
impl Default for random_data {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
impl Default for __locale_struct {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_2 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_2 = 250;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_stdio_file {
    pub file: *mut FILE,
}
#[test]
fn bindgen_test_layout_blosc2_stdio_file() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_stdio_file> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_stdio_file>(),
        8usize,
        concat!("Size of: ", stringify!(blosc2_stdio_file))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_stdio_file>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_stdio_file))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_stdio_file),
            "::",
            stringify!(file)
        )
    );
}
impl Default for blosc2_stdio_file {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn blosc2_stdio_open(
        urlpath: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
        params: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn blosc2_stdio_close(stream: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc2_stdio_tell(stream: *mut ::std::os::raw::c_void) -> i64;
}
extern "C" {
    pub fn blosc2_stdio_seek(
        stream: *mut ::std::os::raw::c_void,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc2_stdio_write(
        ptr: *const ::std::os::raw::c_void,
        size: i64,
        nitems: i64,
        stream: *mut ::std::os::raw::c_void,
    ) -> i64;
}
extern "C" {
    pub fn blosc2_stdio_read(
        ptr: *mut ::std::os::raw::c_void,
        size: i64,
        nitems: i64,
        stream: *mut ::std::os::raw::c_void,
    ) -> i64;
}
extern "C" {
    pub fn blosc2_stdio_truncate(
        stream: *mut ::std::os::raw::c_void,
        size: i64,
    ) -> ::std::os::raw::c_int;
}
pub const BLOSC1_VERSION_FORMAT_PRE1: _bindgen_ty_4 = 1;
pub const BLOSC1_VERSION_FORMAT: _bindgen_ty_4 = 2;
pub const BLOSC2_VERSION_FORMAT_ALPHA: _bindgen_ty_4 = 3;
pub const BLOSC2_VERSION_FORMAT_BETA1: _bindgen_ty_4 = 4;
pub const BLOSC2_VERSION_FORMAT_STABLE: _bindgen_ty_4 = 5;
pub const BLOSC2_VERSION_FORMAT: _bindgen_ty_4 = 5;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const BLOSC2_VERSION_FRAME_FORMAT_BETA2: _bindgen_ty_5 = 1;
pub const BLOSC2_VERSION_FRAME_FORMAT_RC1: _bindgen_ty_5 = 2;
pub const BLOSC2_VERSION_FRAME_FORMAT: _bindgen_ty_5 = 2;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blosc2_instr {
    pub cratio: f32,
    pub cspeed: f32,
    pub filter_speed: f32,
    pub flags: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_blosc2_instr() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_instr> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_instr>(),
        16usize,
        concat!("Size of: ", stringify!(blosc2_instr))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_instr>(),
        4usize,
        concat!("Alignment of ", stringify!(blosc2_instr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cratio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_instr),
            "::",
            stringify!(cratio)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cspeed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_instr),
            "::",
            stringify!(cspeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_speed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_instr),
            "::",
            stringify!(filter_speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_instr),
            "::",
            stringify!(flags)
        )
    );
}
pub const BLOSC_MIN_HEADER_LENGTH: _bindgen_ty_6 = 16;
pub const BLOSC_EXTENDED_HEADER_LENGTH: _bindgen_ty_6 = 32;
pub const BLOSC2_MAX_OVERHEAD: _bindgen_ty_6 = 32;
pub const BLOSC2_MAX_BUFFERSIZE: _bindgen_ty_6 = 2147483615;
pub const BLOSC_MAX_TYPESIZE: _bindgen_ty_6 = 255;
pub const BLOSC_MIN_BUFFERSIZE: _bindgen_ty_6 = 32;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const BLOSC2_DEFINED_FILTERS_START: _bindgen_ty_7 = 0;
pub const BLOSC2_DEFINED_FILTERS_STOP: _bindgen_ty_7 = 31;
pub const BLOSC2_GLOBAL_REGISTERED_FILTERS_START: _bindgen_ty_7 = 32;
pub const BLOSC2_GLOBAL_REGISTERED_FILTERS_STOP: _bindgen_ty_7 = 159;
pub const BLOSC2_GLOBAL_REGISTERED_FILTERS: _bindgen_ty_7 = 3;
pub const BLOSC2_USER_REGISTERED_FILTERS_START: _bindgen_ty_7 = 160;
pub const BLOSC2_USER_REGISTERED_FILTERS_STOP: _bindgen_ty_7 = 255;
pub const BLOSC2_MAX_FILTERS: _bindgen_ty_7 = 6;
pub const BLOSC2_MAX_UDFILTERS: _bindgen_ty_7 = 16;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[doc = "!< No shuffle (for compatibility with Blosc1)."]
pub const BLOSC_NOSHUFFLE: _bindgen_ty_8 = 0;
#[doc = "!< No filter."]
pub const BLOSC_NOFILTER: _bindgen_ty_8 = 0;
#[doc = "!< Byte-wise shuffle."]
pub const BLOSC_SHUFFLE: _bindgen_ty_8 = 1;
#[doc = "!< Bit-wise shuffle."]
pub const BLOSC_BITSHUFFLE: _bindgen_ty_8 = 2;
#[doc = "!< Delta filter."]
pub const BLOSC_DELTA: _bindgen_ty_8 = 3;
#[doc = "!< Truncate mantissa precision; positive values in cparams.filters_meta will keep bits; negative values will reduce bits."]
pub const BLOSC_TRUNC_PREC: _bindgen_ty_8 = 4;
#[doc = "!< sentinel"]
pub const BLOSC_LAST_FILTER: _bindgen_ty_8 = 5;
pub const BLOSC_LAST_REGISTERED_FILTER: _bindgen_ty_8 = 34;
#[doc = " @brief Codes for filters.\n\n @sa #blosc1_compress"]
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
#[doc = "!< byte-wise shuffle"]
pub const BLOSC_DOSHUFFLE: _bindgen_ty_9 = 1;
#[doc = "!< plain copy"]
pub const BLOSC_MEMCPYED: _bindgen_ty_9 = 2;
#[doc = "!< bit-wise shuffle"]
pub const BLOSC_DOBITSHUFFLE: _bindgen_ty_9 = 4;
#[doc = "!< delta coding"]
pub const BLOSC_DODELTA: _bindgen_ty_9 = 8;
#[doc = " @brief Codes for internal flags (see blosc1_cbuffer_metainfo)"]
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[doc = "!< use dictionaries with codec"]
pub const BLOSC2_USEDICT: _bindgen_ty_10 = 1;
#[doc = "!< data is in big-endian ordering"]
pub const BLOSC2_BIGENDIAN: _bindgen_ty_10 = 2;
#[doc = "!< codec is instrumented (mainly for development)"]
pub const BLOSC2_INSTR_CODEC: _bindgen_ty_10 = 128;
#[doc = " @brief Codes for new internal flags in Blosc2"]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[doc = "!< maximum size for compression dicts"]
pub const BLOSC2_MAXDICTSIZE: _bindgen_ty_11 = 131072;
#[doc = "!< maximum size for blocks"]
pub const BLOSC2_MAXBLOCKSIZE: _bindgen_ty_11 = 536866816;
#[doc = " @brief Values for different Blosc2 capabilities"]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
pub const BLOSC2_DEFINED_CODECS_START: _bindgen_ty_12 = 0;
pub const BLOSC2_DEFINED_CODECS_STOP: _bindgen_ty_12 = 31;
pub const BLOSC2_GLOBAL_REGISTERED_CODECS_START: _bindgen_ty_12 = 32;
pub const BLOSC2_GLOBAL_REGISTERED_CODECS_STOP: _bindgen_ty_12 = 159;
pub const BLOSC2_GLOBAL_REGISTERED_CODECS: _bindgen_ty_12 = 1;
pub const BLOSC2_USER_REGISTERED_CODECS_START: _bindgen_ty_12 = 160;
pub const BLOSC2_USER_REGISTERED_CODECS_STOP: _bindgen_ty_12 = 255;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
pub const BLOSC_BLOSCLZ: _bindgen_ty_13 = 0;
pub const BLOSC_LZ4: _bindgen_ty_13 = 1;
pub const BLOSC_LZ4HC: _bindgen_ty_13 = 2;
pub const BLOSC_ZLIB: _bindgen_ty_13 = 4;
pub const BLOSC_ZSTD: _bindgen_ty_13 = 5;
pub const BLOSC_LAST_CODEC: _bindgen_ty_13 = 6;
pub const BLOSC_LAST_REGISTERED_CODEC: _bindgen_ty_13 = 32;
#[doc = " @brief Codes for the different compressors shipped with Blosc"]
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const BLOSC_BLOSCLZ_LIB: _bindgen_ty_14 = 0;
pub const BLOSC_LZ4_LIB: _bindgen_ty_14 = 1;
pub const BLOSC_ZLIB_LIB: _bindgen_ty_14 = 3;
pub const BLOSC_ZSTD_LIB: _bindgen_ty_14 = 4;
pub const BLOSC_UDCODEC_LIB: _bindgen_ty_14 = 6;
#[doc = "!< compressor library in super-chunk header"]
pub const BLOSC_SCHUNK_LIB: _bindgen_ty_14 = 7;
#[doc = " @brief Codes for compression libraries shipped with Blosc (code must be < 8)"]
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const BLOSC_BLOSCLZ_FORMAT: _bindgen_ty_15 = 0;
pub const BLOSC_LZ4_FORMAT: _bindgen_ty_15 = 1;
pub const BLOSC_LZ4HC_FORMAT: _bindgen_ty_15 = 1;
pub const BLOSC_ZLIB_FORMAT: _bindgen_ty_15 = 3;
pub const BLOSC_ZSTD_FORMAT: _bindgen_ty_15 = 4;
pub const BLOSC_UDCODEC_FORMAT: _bindgen_ty_15 = 6;
#[doc = " @brief The codes for compressor formats shipped with Blosc"]
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const BLOSC_BLOSCLZ_VERSION_FORMAT: _bindgen_ty_16 = 1;
pub const BLOSC_LZ4_VERSION_FORMAT: _bindgen_ty_16 = 1;
pub const BLOSC_LZ4HC_VERSION_FORMAT: _bindgen_ty_16 = 1;
pub const BLOSC_ZLIB_VERSION_FORMAT: _bindgen_ty_16 = 1;
pub const BLOSC_ZSTD_VERSION_FORMAT: _bindgen_ty_16 = 1;
pub const BLOSC_UDCODEC_VERSION_FORMAT: _bindgen_ty_16 = 1;
#[doc = " @brief The version formats for compressors shipped with Blosc.\n All versions here starts at 1"]
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const BLOSC_ALWAYS_SPLIT: _bindgen_ty_17 = 1;
pub const BLOSC_NEVER_SPLIT: _bindgen_ty_17 = 2;
pub const BLOSC_AUTO_SPLIT: _bindgen_ty_17 = 3;
pub const BLOSC_FORWARD_COMPAT_SPLIT: _bindgen_ty_17 = 4;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
#[doc = "!< the version for the chunk format"]
pub const BLOSC2_CHUNK_VERSION: _bindgen_ty_18 = 0;
#[doc = "!< the version for the format of internal codec"]
pub const BLOSC2_CHUNK_VERSIONLZ: _bindgen_ty_18 = 1;
#[doc = "!< flags and codec info"]
pub const BLOSC2_CHUNK_FLAGS: _bindgen_ty_18 = 2;
#[doc = "!< (uint8) the number of bytes of the atomic type"]
pub const BLOSC2_CHUNK_TYPESIZE: _bindgen_ty_18 = 3;
#[doc = "!< (int32) uncompressed size of the buffer (this header is not included)"]
pub const BLOSC2_CHUNK_NBYTES: _bindgen_ty_18 = 4;
#[doc = "!< (int32) size of internal blocks"]
pub const BLOSC2_CHUNK_BLOCKSIZE: _bindgen_ty_18 = 8;
#[doc = "!< (int32) compressed size of the buffer (including this header)"]
pub const BLOSC2_CHUNK_CBYTES: _bindgen_ty_18 = 12;
#[doc = "!< the codecs for the filter pipeline (1 byte per code)"]
pub const BLOSC2_CHUNK_FILTER_CODES: _bindgen_ty_18 = 16;
#[doc = "!< meta info for the filter pipeline (1 byte per code)"]
pub const BLOSC2_CHUNK_FILTER_META: _bindgen_ty_18 = 24;
#[doc = "!< flags specific for Blosc2 functionality"]
pub const BLOSC2_CHUNK_BLOSC2_FLAGS: _bindgen_ty_18 = 31;
#[doc = " @brief Offsets for fields in Blosc2 chunk header."]
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
#[doc = "!< no special value"]
pub const BLOSC2_NO_SPECIAL: _bindgen_ty_19 = 0;
#[doc = "!< zero special value"]
pub const BLOSC2_SPECIAL_ZERO: _bindgen_ty_19 = 1;
#[doc = "!< NaN special value"]
pub const BLOSC2_SPECIAL_NAN: _bindgen_ty_19 = 2;
#[doc = "!< generic special value"]
pub const BLOSC2_SPECIAL_VALUE: _bindgen_ty_19 = 3;
#[doc = "!< non initialized values"]
pub const BLOSC2_SPECIAL_UNINIT: _bindgen_ty_19 = 4;
#[doc = "!< last valid ID for special value (update this adequately)"]
pub const BLOSC2_SPECIAL_LASTID: _bindgen_ty_19 = 4;
#[doc = "!< special value mask (prev IDs cannot be larger than this)"]
pub const BLOSC2_SPECIAL_MASK: _bindgen_ty_19 = 7;
#[doc = " @brief Run lengths for special values for chunks/frames"]
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
pub const BLOSC2_ERROR_SUCCESS: _bindgen_ty_20 = 0;
pub const BLOSC2_ERROR_FAILURE: _bindgen_ty_20 = -1;
pub const BLOSC2_ERROR_STREAM: _bindgen_ty_20 = -2;
pub const BLOSC2_ERROR_DATA: _bindgen_ty_20 = -3;
pub const BLOSC2_ERROR_MEMORY_ALLOC: _bindgen_ty_20 = -4;
#[doc = "!< Not enough space to read"]
pub const BLOSC2_ERROR_READ_BUFFER: _bindgen_ty_20 = -5;
#[doc = "!< Not enough space to write"]
pub const BLOSC2_ERROR_WRITE_BUFFER: _bindgen_ty_20 = -6;
#[doc = "!< Codec not supported"]
pub const BLOSC2_ERROR_CODEC_SUPPORT: _bindgen_ty_20 = -7;
#[doc = "!< Invalid parameter supplied to codec"]
pub const BLOSC2_ERROR_CODEC_PARAM: _bindgen_ty_20 = -8;
#[doc = "!< Codec dictionary error"]
pub const BLOSC2_ERROR_CODEC_DICT: _bindgen_ty_20 = -9;
#[doc = "!< Version not supported"]
pub const BLOSC2_ERROR_VERSION_SUPPORT: _bindgen_ty_20 = -10;
#[doc = "!< Invalid value in header"]
pub const BLOSC2_ERROR_INVALID_HEADER: _bindgen_ty_20 = -11;
#[doc = "!< Invalid parameter supplied to function"]
pub const BLOSC2_ERROR_INVALID_PARAM: _bindgen_ty_20 = -12;
#[doc = "!< File read failure"]
pub const BLOSC2_ERROR_FILE_READ: _bindgen_ty_20 = -13;
#[doc = "!< File write failure"]
pub const BLOSC2_ERROR_FILE_WRITE: _bindgen_ty_20 = -14;
#[doc = "!< File open failure"]
pub const BLOSC2_ERROR_FILE_OPEN: _bindgen_ty_20 = -15;
#[doc = "!< Not found"]
pub const BLOSC2_ERROR_NOT_FOUND: _bindgen_ty_20 = -16;
#[doc = "!< Bad run length encoding"]
pub const BLOSC2_ERROR_RUN_LENGTH: _bindgen_ty_20 = -17;
#[doc = "!< Filter pipeline error"]
pub const BLOSC2_ERROR_FILTER_PIPELINE: _bindgen_ty_20 = -18;
#[doc = "!< Chunk insert failure"]
pub const BLOSC2_ERROR_CHUNK_INSERT: _bindgen_ty_20 = -19;
#[doc = "!< Chunk append failure"]
pub const BLOSC2_ERROR_CHUNK_APPEND: _bindgen_ty_20 = -20;
#[doc = "!< Chunk update failure"]
pub const BLOSC2_ERROR_CHUNK_UPDATE: _bindgen_ty_20 = -21;
#[doc = "!< Sizes larger than 2gb not supported"]
pub const BLOSC2_ERROR_2GB_LIMIT: _bindgen_ty_20 = -22;
#[doc = "!< Super-chunk copy failure"]
pub const BLOSC2_ERROR_SCHUNK_COPY: _bindgen_ty_20 = -23;
#[doc = "!< Wrong type for frame"]
pub const BLOSC2_ERROR_FRAME_TYPE: _bindgen_ty_20 = -24;
#[doc = "!< File truncate failure"]
pub const BLOSC2_ERROR_FILE_TRUNCATE: _bindgen_ty_20 = -25;
#[doc = "!< Thread or thread context creation failure"]
pub const BLOSC2_ERROR_THREAD_CREATE: _bindgen_ty_20 = -26;
#[doc = "!< Postfilter failure"]
pub const BLOSC2_ERROR_POSTFILTER: _bindgen_ty_20 = -27;
#[doc = "!< Special frame failure"]
pub const BLOSC2_ERROR_FRAME_SPECIAL: _bindgen_ty_20 = -28;
#[doc = "!< Special super-chunk failure"]
pub const BLOSC2_ERROR_SCHUNK_SPECIAL: _bindgen_ty_20 = -29;
#[doc = "!< IO plugin error"]
pub const BLOSC2_ERROR_PLUGIN_IO: _bindgen_ty_20 = -30;
#[doc = "!< Remove file failure"]
pub const BLOSC2_ERROR_FILE_REMOVE: _bindgen_ty_20 = -31;
#[doc = "!< Pointer is null"]
pub const BLOSC2_ERROR_NULL_POINTER: _bindgen_ty_20 = -32;
#[doc = "!< Invalid index"]
pub const BLOSC2_ERROR_INVALID_INDEX: _bindgen_ty_20 = -33;
#[doc = "!< Metalayer has not been found"]
pub const BLOSC2_ERROR_METALAYER_NOT_FOUND: _bindgen_ty_20 = -34;
#[doc = " @brief Error codes"]
pub type _bindgen_ty_20 = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @brief Initialize the Blosc library environment.\n\n You must call this previous to any other Blosc call, unless you want\n Blosc to be used simultaneously in a multi-threaded environment, in\n which case you can use the #blosc2_compress_ctx #blosc2_decompress_ctx pair.\n\n @sa #blosc2_destroy"]
    pub fn blosc2_init();
}
extern "C" {
    #[doc = " @brief Destroy the Blosc library environment.\n\n You must call this after to you are done with all the Blosc calls,\n unless you have not used blosc2_init() before.\n\n @sa #blosc2_init"]
    pub fn blosc2_destroy();
}
extern "C" {
    #[doc = " @brief Compress a block of data in the @p src buffer and returns the size of\n compressed block.\n\n @remark Compression is memory safe and guaranteed not to write @p dest\n more than what is specified in @p destsize.\n There is not a minimum for @p src buffer size @p nbytes.\n\n @warning The @p src buffer and the @p dest buffer can not overlap.\n\n @param clevel The desired compression level and must be a number\n between 0 (no compression) and 9 (maximum compression).\n @param doshuffle Specifies whether the shuffle compression preconditioner\n should be applied or not. #BLOSC_NOFILTER means not applying filters,\n #BLOSC_SHUFFLE means applying shuffle at a byte level and\n #BLOSC_BITSHUFFLE at a bit level (slower but *may* achieve better\n compression).\n @param typesize Is the number of bytes for the atomic type in binary\n @p src buffer.  This is mainly useful for the shuffle preconditioner.\n For implementation reasons, only a 1 < typesize < 256 will allow the\n shuffle filter to work.  When typesize is not in this range, shuffle\n will be silently disabled.\n @param nbytes The number of bytes to compress in the @p src buffer.\n @param src The buffer containing the data to compress.\n @param dest The buffer where the compressed data will be put,\n must have at least the size of @p destsize.\n @param destsize The size of the dest buffer. Blosc\n guarantees that if you set @p destsize to, at least,\n (@p nbytes + #BLOSC2_MAX_OVERHEAD), the compression will always succeed.\n\n @return The number of bytes compressed.\n If @p src buffer cannot be compressed into @p destsize, the return\n value is zero and you should discard the contents of the @p dest\n buffer. A negative return value means that an internal error happened. This\n should never happen. If you see this, please report it back\n together with the buffer data causing this and compression settings.\n\n\n @par Environment variables\n @parblock\n\n This function honors different environment variables to control\n internal parameters without the need of doing that programmatically.\n Here are the ones supported:\n\n * **BLOSC_CLEVEL=(INTEGER)**: This will overwrite the @p clevel parameter\n before the compression process starts.\n\n * **BLOSC_SHUFFLE=[NOSHUFFLE | SHUFFLE | BITSHUFFLE]**: This will\n overwrite the @p doshuffle parameter before the compression process\n starts.\n\n * **BLOSC_DELTA=(1|0)**: This will call #blosc2_set_delta() before the\n compression process starts.\n\n * **BLOSC_TYPESIZE=(INTEGER)**: This will overwrite the @p typesize\n parameter before the compression process starts.\n\n * **BLOSC_COMPRESSOR=[BLOSCLZ | LZ4 | LZ4HC | ZLIB | ZSTD]**:\n This will call #blosc1_set_compressor before the compression process starts.\n\n * **BLOSC_NTHREADS=(INTEGER)**: This will call\n #blosc2_set_nthreads before the compression process starts.\n\n * **BLOSC_SPLITMODE=(ALWAYS | NEVER | AUTO | FORWARD_COMPAT)**:\n This will call #blosc1_set_splitmode() before the compression process starts.\n\n * **BLOSC_BLOCKSIZE=(INTEGER)**: This will call\n #blosc1_set_blocksize before the compression process starts.\n *NOTE:* The *blocksize* is a critical parameter with\n important restrictions in the allowed values, so use this with care.\n\n * **BLOSC_NOLOCK=(ANY VALUE)**: This will call #blosc2_compress_ctx under\n the hood, with the *compressor*, *blocksize* and\n *numinternalthreads* parameters set to the same as the last calls to\n #blosc1_set_compressor, #blosc1_set_blocksize and\n #blosc2_set_nthreads. *BLOSC_CLEVEL*, *BLOSC_SHUFFLE*, *BLOSC_DELTA* and\n *BLOSC_TYPESIZE* environment vars will also be honored.\n\n @endparblock\n\n @sa #blosc1_decompress"]
    pub fn blosc1_compress(
        clevel: ::std::os::raw::c_int,
        doshuffle: ::std::os::raw::c_int,
        typesize: usize,
        nbytes: usize,
        src: *const ::std::os::raw::c_void,
        dest: *mut ::std::os::raw::c_void,
        destsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Decompress a block of compressed data in @p src, put the result in\n @p dest and returns the size of the decompressed block.\n\n @warning The @p src buffer and the @p dest buffer can not overlap.\n\n @remark Decompression is memory safe and guaranteed not to write the @p dest\n buffer more than what is specified in @p destsize.\n\n @remark In case you want to keep under control the number of bytes read from\n source, you can call #blosc1_cbuffer_sizes first to check whether the\n @p nbytes (i.e. the number of bytes to be read from @p src buffer by this\n function) in the compressed buffer is ok with you.\n\n @param src The buffer to be decompressed.\n @param dest The buffer where the decompressed data will be put.\n @param destsize The size of the @p dest buffer.\n\n @return The number of bytes decompressed.\n If an error occurs, e.g. the compressed data is corrupted or the\n output buffer is not large enough, then a negative value\n will be returned instead.\n\n @par Environment variables\n @parblock\n This function honors different environment variables to control\n internal parameters without the need of doing that programmatically.\n Here are the ones supported:\n\n * **BLOSC_NTHREADS=(INTEGER)**: This will call\n #blosc2_set_nthreads before the proper decompression\n process starts.\n\n * **BLOSC_NOLOCK=(ANY VALUE)**: This will call #blosc2_decompress_ctx\n under the hood, with the *numinternalthreads* parameter set to the\n same value as the last call to #blosc2_set_nthreads.\n\n @endparblock\n\n @sa #blosc1_compress"]
    pub fn blosc1_decompress(
        src: *const ::std::os::raw::c_void,
        dest: *mut ::std::os::raw::c_void,
        destsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get @p nitems (of @p typesize size) in @p src buffer starting in @p start.\n The items are returned in @p dest buffer, which has to have enough\n space for storing all items.\n\n @param src The compressed buffer from data will be decompressed.\n @param start The position of the first item (of @p typesize size) from where data\n will be retrieved.\n @param nitems The number of items (of @p typesize size) that will be retrieved.\n @param dest The buffer where the decompressed data retrieved will be put.\n\n @return The number of bytes copied to @p dest or a negative value if\n some error happens."]
    pub fn blosc1_getitem(
        src: *const ::std::os::raw::c_void,
        start: ::std::os::raw::c_int,
        nitems: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get @p nitems (of @p typesize size) in @p src buffer starting in @p start.\n The items are returned in @p dest buffer. The dest buffer should have enough space\n for storing all items. This function is a more secure version of #blosc1_getitem.\n\n @param src The compressed buffer holding the data to be retrieved.\n @param srcsize Size of the compressed buffer.\n @param start The position of the first item (of @p typesize size) from where data\n will be retrieved.\n @param nitems The number of items (of @p typesize size) that will be retrieved.\n @param dest The buffer where the retrieved data will be stored decompressed.\n @param destsize Size of the buffer where retrieved data will be stored.\n\n @return The number of bytes copied to @p dest or a negative value if\n some error happens."]
    pub fn blosc2_getitem(
        src: *const ::std::os::raw::c_void,
        srcsize: i32,
        start: ::std::os::raw::c_int,
        nitems: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
#[doc = "Pointer to a callback function that executes `dojob(jobdata + i*jobdata_elsize)` for `i = 0 to numjobs-1`,\npossibly in parallel threads (but not returning until all `dojob` calls have returned).   This allows the\ncaller to provide a custom threading backend as an alternative to the default Blosc-managed threads.\n`callback_data` is passed through from `blosc2_set_threads_callback`."]
pub type blosc_threads_callback = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        dojob: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        numjobs: ::std::os::raw::c_int,
        jobdata_elsize: usize,
        jobdata: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = "Set the threading backend for parallel compression/decompression to use `callback` to execute work\ninstead of using the Blosc-managed threads.   This function is *not* thread-safe and should be called\nbefore any other Blosc function: it affects all Blosc contexts.  Passing `NULL` uses the default\nBlosc threading backend.  The `callback_data` argument is passed through to the callback."]
    pub fn blosc2_set_threads_callback(
        callback: blosc_threads_callback,
        callback_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " @brief Returns the current number of threads that are used for\n compression/decompression."]
    pub fn blosc2_get_nthreads() -> i16;
}
extern "C" {
    #[doc = " @brief Initialize a pool of threads for compression/decompression. If\n @p nthreads is 1, then the serial version is chosen and a possible\n previous existing pool is ended. If this is not called, @p nthreads\n is set to 1 internally.\n\n @param nthreads The number of threads to use.\n\n @return The previous number of threads."]
    pub fn blosc2_set_nthreads(nthreads: i16) -> i16;
}
extern "C" {
    #[doc = " @brief Get the current compressor that is used for compression.\n\n @return The string identifying the compressor being used."]
    pub fn blosc1_get_compressor() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Select the compressor to be used. The supported ones are \"blosclz\",\n \"lz4\", \"lz4hc\", \"zlib\" and \"ztsd\". If this function is not\n called, then \"blosclz\" will be used.\n\n @param compname The name identifier of the compressor to be set.\n\n @return The code for the compressor (>=0). In case the compressor\n is not recognized, or there is not support for it in this build,\n it returns a -1."]
    pub fn blosc1_set_compressor(compname: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Select the delta coding filter to be used.\n\n @param dodelta A value >0 will activate the delta filter.\n If 0, it will be de-activated\n\n This call should always succeed."]
    pub fn blosc2_set_delta(dodelta: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Get the compressor name associated with the compressor code.\n\n @param compcode The code identifying the compressor\n @param compname The pointer to a string where the compressor name will be put.\n\n @return The compressor code. If the compressor code is not recognized,\n or there is not support for it in this build, -1 is returned."]
    pub fn blosc2_compcode_to_compname(
        compcode: ::std::os::raw::c_int,
        compname: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the compressor code associated with the compressor name.\n\n @param compname The string containing the compressor name.\n\n @return The compressor code. If the compressor name is not recognized,\n or there is not support for it in this build, -1 is returned instead."]
    pub fn blosc2_compname_to_compcode(
        compname: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get a list of compressors supported in the current build.\n\n @return The comma separated string with the list of compressor names\n supported.\n\n This function does not leak, so you should not free() the returned\n list.\n\n This function should always succeed."]
    pub fn blosc2_list_compressors() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get the version of Blosc in string format.\n\n @return The string with the current Blosc version.\n Useful for dynamic libraries."]
    pub fn blosc2_get_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Get info from compression libraries included in the current build.\n\n @param compname The compressor name that you want info from.\n @param complib The pointer to a string where the\n compression library name, if available, will be put.\n @param version The pointer to a string where the\n compression library version, if available, will be put.\n\n @warning You are in charge of the @p complib and @p version strings,\n you should free() them so as to avoid leaks.\n\n @return The code for the compression library (>=0). If it is not supported,\n this function returns -1."]
    pub fn blosc2_get_complib_info(
        compname: *const ::std::os::raw::c_char,
        complib: *mut *mut ::std::os::raw::c_char,
        version: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Free possible memory temporaries and thread resources. Use this\n when you are not going to use Blosc for a long while.\n\n @return A 0 if succeeds, in case of problems releasing the resources,\n it returns a negative number."]
    pub fn blosc2_free_resources() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get information about a compressed buffer, namely the number of\n uncompressed bytes (@p nbytes) and compressed (@p cbytes). It also\n returns the @p blocksize (which is used internally for doing the\n compression by blocks).\n\n @param cbuffer The buffer of compressed data.\n @param nbytes The pointer where the number of uncompressed bytes will be put.\n @param cbytes The pointer where the number of compressed bytes will be put.\n @param blocksize The pointer where the block size will be put.\n\n You only need to pass the first BLOSC_MIN_HEADER_LENGTH bytes of a\n compressed buffer for this call to work.\n\n This function should always succeed."]
    pub fn blosc1_cbuffer_sizes(
        cbuffer: *const ::std::os::raw::c_void,
        nbytes: *mut usize,
        cbytes: *mut usize,
        blocksize: *mut usize,
    );
}
extern "C" {
    #[doc = " @brief Get information about a compressed buffer, namely the number of\n uncompressed bytes (@p nbytes) and compressed (@p cbytes). It also\n returns the @p blocksize (which is used internally for doing the\n compression by blocks).\n\n @param cbuffer The buffer of compressed data.\n @param nbytes The pointer where the number of uncompressed bytes will be put.\n @param cbytes The pointer where the number of compressed bytes will be put.\n @param blocksize The pointer where the block size will be put.\n\n @note: if any of the nbytes, cbytes or blocksize is NULL, it will not be returned.\n\n You only need to pass the first BLOSC_MIN_HEADER_LENGTH bytes of a\n compressed buffer for this call to work.\n\n @return On failure, returns negative value."]
    pub fn blosc2_cbuffer_sizes(
        cbuffer: *const ::std::os::raw::c_void,
        nbytes: *mut i32,
        cbytes: *mut i32,
        blocksize: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Checks that the compressed buffer starting at @p cbuffer of length @p cbytes\n may contain valid blosc compressed data, and that it is safe to call\n blosc1_decompress/blosc1_getitem.\n On success, returns 0 and sets @p nbytes to the size of the uncompressed data.\n This does not guarantee that the decompression function won't return an error,\n but does guarantee that it is safe to attempt decompression.\n\n @param cbuffer The buffer of compressed data.\n @param cbytes The number of compressed bytes.\n @param nbytes The pointer where the number of uncompressed bytes will be put.\n\n @return On failure, returns negative value."]
    pub fn blosc1_cbuffer_validate(
        cbuffer: *const ::std::os::raw::c_void,
        cbytes: usize,
        nbytes: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get information about a compressed buffer, namely the type size\n (@p typesize), as well as some internal @p flags.\n\n @param cbuffer The buffer of compressed data.\n @param typesize The pointer where the type size will be put.\n @param flags The pointer of the integer where the additional info is encoded.\n The @p flags is a set of bits, where the currently used ones are:\n   * bit 0: whether the shuffle filter has been applied or not\n   * bit 1: whether the internal buffer is a pure memcpy or not\n   * bit 2: whether the bitshuffle filter has been applied or not\n   * bit 3: whether the delta coding filter has been applied or not\n\n You can use the @p BLOSC_DOSHUFFLE, @p BLOSC_DOBITSHUFFLE, @p BLOSC_DODELTA\n and @p BLOSC_MEMCPYED symbols for extracting the interesting bits\n (e.g. @p flags & @p BLOSC_DOSHUFFLE says whether the buffer is byte-shuffled\n or not).\n\n This function should always succeed."]
    pub fn blosc1_cbuffer_metainfo(
        cbuffer: *const ::std::os::raw::c_void,
        typesize: *mut usize,
        flags: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Get information about a compressed buffer, namely the internal\n Blosc format version (@p version) and the format for the internal\n Lempel-Ziv compressor used (@p versionlz).\n\n @param cbuffer The buffer of compressed data.\n @param version The pointer where the Blosc format version will be put.\n @param versionlz The pointer where the Lempel-Ziv version will be put.\n\n This function should always succeed."]
    pub fn blosc2_cbuffer_versions(
        cbuffer: *const ::std::os::raw::c_void,
        version: *mut ::std::os::raw::c_int,
        versionlz: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Get the compressor library/format used in a compressed buffer.\n\n @param cbuffer The buffer of compressed data.\n\n @return The string identifying the compressor library/format used.\n\n This function should always succeed."]
    pub fn blosc2_cbuffer_complib(
        cbuffer: *const ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub const BLOSC2_IO_FILESYSTEM: _bindgen_ty_21 = 0;
pub const BLOSC_IO_LAST_BLOSC_DEFINED: _bindgen_ty_21 = 1;
pub const BLOSC_IO_LAST_REGISTERED: _bindgen_ty_21 = 32;
#[doc = "Structures and functions related with user-defined input/output."]
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const BLOSC2_IO_BLOSC_DEFINED: _bindgen_ty_22 = 32;
pub const BLOSC2_IO_REGISTERED: _bindgen_ty_22 = 160;
pub const BLOSC2_IO_USER_DEFINED: _bindgen_ty_22 = 256;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
pub type blosc2_open_cb = ::std::option::Option<
    unsafe extern "C" fn(
        urlpath: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
        params: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type blosc2_close_cb = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
pub type blosc2_tell_cb =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut ::std::os::raw::c_void) -> i64>;
pub type blosc2_seek_cb = ::std::option::Option<
    unsafe extern "C" fn(
        stream: *mut ::std::os::raw::c_void,
        offset: i64,
        whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type blosc2_write_cb = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *const ::std::os::raw::c_void,
        size: i64,
        nitems: i64,
        stream: *mut ::std::os::raw::c_void,
    ) -> i64,
>;
pub type blosc2_read_cb = ::std::option::Option<
    unsafe extern "C" fn(
        ptr: *mut ::std::os::raw::c_void,
        size: i64,
        nitems: i64,
        stream: *mut ::std::os::raw::c_void,
    ) -> i64,
>;
pub type blosc2_truncate_cb = ::std::option::Option<
    unsafe extern "C" fn(stream: *mut ::std::os::raw::c_void, size: i64) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blosc2_io_cb {
    pub id: u8,
    pub open: blosc2_open_cb,
    pub close: blosc2_close_cb,
    pub tell: blosc2_tell_cb,
    pub seek: blosc2_seek_cb,
    pub write: blosc2_write_cb,
    pub read: blosc2_read_cb,
    pub truncate: blosc2_truncate_cb,
}
#[test]
fn bindgen_test_layout_blosc2_io_cb() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_io_cb> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_io_cb>(),
        64usize,
        concat!("Size of: ", stringify!(blosc2_io_cb))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_io_cb>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_io_cb))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io_cb),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io_cb),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io_cb),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io_cb),
            "::",
            stringify!(tell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io_cb),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io_cb),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io_cb),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).truncate) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io_cb),
            "::",
            stringify!(truncate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_io {
    pub id: u8,
    pub params: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_blosc2_io() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_io> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_io>(),
        16usize,
        concat!("Size of: ", stringify!(blosc2_io))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_io>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_io))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_io),
            "::",
            stringify!(params)
        )
    );
}
impl Default for blosc2_io {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut BLOSC2_IO_CB_DEFAULTS: blosc2_io_cb;
}
extern "C" {
    pub static BLOSC2_IO_DEFAULTS: blosc2_io;
}
extern "C" {
    #[doc = " @brief Register a user-defined input/output callbacks in Blosc.\n\n @param io The callbacks API to register.\n\n @return 0 if succeeds. Else a negative code is returned."]
    pub fn blosc2_register_io_cb(io: *const blosc2_io_cb) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc2_get_io_cb(id: u8) -> *mut blosc2_io_cb;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_context_s {
    _unused: [u8; 0],
}
#[doc = "Structures and functions related with contexts."]
pub type blosc2_context = blosc2_context_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_btune {
    pub btune_init: ::std::option::Option<
        unsafe extern "C" fn(
            config: *mut ::std::os::raw::c_void,
            cctx: *mut blosc2_context,
            dctx: *mut blosc2_context,
        ),
    >,
    pub btune_next_blocksize:
        ::std::option::Option<unsafe extern "C" fn(context: *mut blosc2_context)>,
    pub btune_next_cparams:
        ::std::option::Option<unsafe extern "C" fn(context: *mut blosc2_context)>,
    pub btune_update:
        ::std::option::Option<unsafe extern "C" fn(context: *mut blosc2_context, ctime: f64)>,
    pub btune_free: ::std::option::Option<unsafe extern "C" fn(context: *mut blosc2_context)>,
    pub btune_config: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_blosc2_btune() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_btune> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_btune>(),
        48usize,
        concat!("Size of: ", stringify!(blosc2_btune))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_btune>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_btune))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btune_init) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_btune),
            "::",
            stringify!(btune_init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btune_next_blocksize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_btune),
            "::",
            stringify!(btune_next_blocksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btune_next_cparams) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_btune),
            "::",
            stringify!(btune_next_cparams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btune_update) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_btune),
            "::",
            stringify!(btune_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btune_free) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_btune),
            "::",
            stringify!(btune_free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).btune_config) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_btune),
            "::",
            stringify!(btune_config)
        )
    );
}
impl Default for blosc2_btune {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief The parameters for a prefilter function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_prefilter_params {
    pub user_data: *mut ::std::os::raw::c_void,
    pub input: *const u8,
    pub output: *mut u8,
    pub output_size: i32,
    pub output_typesize: i32,
    pub output_offset: i32,
    pub nchunk: i64,
    pub nblock: i32,
    pub tid: i32,
    pub ttmp: *mut u8,
    pub ttmp_nbytes: usize,
    pub ctx: *mut blosc2_context,
}
#[test]
fn bindgen_test_layout_blosc2_prefilter_params() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_prefilter_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_prefilter_params>(),
        80usize,
        concat!("Size of: ", stringify!(blosc2_prefilter_params))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_prefilter_params>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_prefilter_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_typesize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(output_typesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(output_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nchunk) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(nchunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nblock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(nblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tid) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttmp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(ttmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttmp_nbytes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(ttmp_nbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_prefilter_params),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for blosc2_prefilter_params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief The parameters for a postfilter function.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_postfilter_params {
    pub user_data: *mut ::std::os::raw::c_void,
    pub input: *const u8,
    pub output: *mut u8,
    pub size: i32,
    pub typesize: i32,
    pub offset: i32,
    pub nchunk: i64,
    pub nblock: i32,
    pub tid: i32,
    pub ttmp: *mut u8,
    pub ttmp_nbytes: usize,
    pub ctx: *mut blosc2_context,
}
#[test]
fn bindgen_test_layout_blosc2_postfilter_params() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_postfilter_params> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_postfilter_params>(),
        80usize,
        concat!("Size of: ", stringify!(blosc2_postfilter_params))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_postfilter_params>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_postfilter_params))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesize) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(typesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nchunk) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(nchunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nblock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(nblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tid) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(tid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttmp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(ttmp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ttmp_nbytes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(ttmp_nbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_postfilter_params),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for blosc2_postfilter_params {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief The type of the prefilter function.\n\n If the function call is successful, the return value should be 0; else, a negative value."]
pub type blosc2_prefilter_fn = ::std::option::Option<
    unsafe extern "C" fn(params: *mut blosc2_prefilter_params) -> ::std::os::raw::c_int,
>;
#[doc = " @brief The type of the postfilter function.\n\n If the function call is successful, the return value should be 0; else, a negative value."]
pub type blosc2_postfilter_fn = ::std::option::Option<
    unsafe extern "C" fn(params: *mut blosc2_postfilter_params) -> ::std::os::raw::c_int,
>;
#[doc = " @brief The parameters for creating a context for compression purposes.\n\n In parenthesis it is shown the default value used internally when a 0\n (zero) in the fields of the struct is passed to a function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_cparams {
    pub compcode: u8,
    pub compcode_meta: u8,
    pub clevel: u8,
    pub use_dict: ::std::os::raw::c_int,
    pub typesize: i32,
    pub nthreads: i16,
    pub blocksize: i32,
    pub splitmode: i32,
    pub schunk: *mut ::std::os::raw::c_void,
    pub filters: [u8; 6usize],
    pub filters_meta: [u8; 6usize],
    pub prefilter: blosc2_prefilter_fn,
    pub preparams: *mut blosc2_prefilter_params,
    pub udbtune: *mut blosc2_btune,
    pub instr_codec: bool,
    pub codec_params: *mut ::std::os::raw::c_void,
    pub filter_params: [*mut ::std::os::raw::c_void; 6usize],
}
#[test]
fn bindgen_test_layout_blosc2_cparams() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_cparams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_cparams>(),
        136usize,
        concat!("Size of: ", stringify!(blosc2_cparams))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_cparams>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_cparams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(compcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compcode_meta) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(compcode_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clevel) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(clevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_dict) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(use_dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(typesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nthreads) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(nthreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blocksize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(blocksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).splitmode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(splitmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schunk) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(schunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filters) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filters_meta) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(filters_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefilter) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(prefilter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preparams) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(preparams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udbtune) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(udbtune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instr_codec) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(instr_codec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codec_params) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(codec_params)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_params) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_cparams),
            "::",
            stringify!(filter_params)
        )
    );
}
impl Default for blosc2_cparams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Default struct for compression params meant for user initialization."]
    pub static BLOSC2_CPARAMS_DEFAULTS: blosc2_cparams;
}
#[doc = "@brief The parameters for creating a context for decompression purposes.\n\nIn parenthesis it is shown the default value used internally when a 0\n(zero) in the fields of the struct is passed to a function."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_dparams {
    pub nthreads: i16,
    pub schunk: *mut ::std::os::raw::c_void,
    pub postfilter: blosc2_postfilter_fn,
    pub postparams: *mut blosc2_postfilter_params,
}
#[test]
fn bindgen_test_layout_blosc2_dparams() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_dparams> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_dparams>(),
        32usize,
        concat!("Size of: ", stringify!(blosc2_dparams))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_dparams>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_dparams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nthreads) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_dparams),
            "::",
            stringify!(nthreads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).schunk) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_dparams),
            "::",
            stringify!(schunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postfilter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_dparams),
            "::",
            stringify!(postfilter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).postparams) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_dparams),
            "::",
            stringify!(postparams)
        )
    );
}
impl Default for blosc2_dparams {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Default struct for decompression params meant for user initialization."]
    pub static BLOSC2_DPARAMS_DEFAULTS: blosc2_dparams;
}
extern "C" {
    #[doc = " @brief Create a context for @a *_ctx() compression functions.\n\n @param cparams The blosc2_cparams struct with the compression parameters.\n\n @return A pointer to the new context. NULL is returned if this fails.\n\n @note This support the same environment variables than #blosc2_compress\n for overriding the programmatic compression values.\n\n @sa #blosc2_compress"]
    pub fn blosc2_create_cctx(cparams: blosc2_cparams) -> *mut blosc2_context;
}
extern "C" {
    #[doc = " @brief Create a context for *_ctx() decompression functions.\n\n @param dparams The blosc2_dparams struct with the decompression parameters.\n\n @return A pointer to the new context. NULL is returned if this fails.\n\n @note This support the same environment variables than #blosc2_decompress\n for overriding the programmatic decompression values.\n\n @sa #blosc2_decompress\n"]
    pub fn blosc2_create_dctx(dparams: blosc2_dparams) -> *mut blosc2_context;
}
extern "C" {
    #[doc = " @brief Free the resources associated with a context.\n\n @param context The context to free.\n\n This function should always succeed and is valid for contexts meant for\n both compression and decompression."]
    pub fn blosc2_free_ctx(context: *mut blosc2_context);
}
extern "C" {
    #[doc = " @brief Create a @p cparams associated to a context.\n\n @param ctx The context from where to extract the compression parameters.\n @param cparams The pointer where the compression params will be stored.\n\n @return 0 if succeeds. Else a negative code is returned."]
    pub fn blosc2_ctx_get_cparams(
        ctx: *mut blosc2_context,
        cparams: *mut blosc2_cparams,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a @p dparams associated to a context.\n\n @param ctx The context from where to extract the decompression parameters.\n @param dparams The pointer where the decompression params will be stored.\n\n @return 0 if succeeds. Else a negative code is returned."]
    pub fn blosc2_ctx_get_dparams(
        ctx: *mut blosc2_context,
        dparams: *mut blosc2_dparams,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set a maskout so as to avoid decompressing specified blocks.\n\n @param ctx The decompression context to update.\n\n @param maskout The boolean mask for the blocks where decompression\n is to be avoided.\n\n @remark The maskout is valid for contexts *only* meant for decompressing\n a chunk via #blosc2_decompress_ctx.  Once a call to #blosc2_decompress_ctx\n is done, this mask is reset so that next call to #blosc2_decompress_ctx\n will decompress the whole chunk.\n\n @param nblocks The number of blocks in maskout above.\n\n @return If success, a 0 is returned.  An error is signaled with a negative int.\n"]
    pub fn blosc2_set_maskout(
        ctx: *mut blosc2_context,
        maskout: *mut bool,
        nblocks: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc2_compress(
        clevel: ::std::os::raw::c_int,
        doshuffle: ::std::os::raw::c_int,
        typesize: i32,
        src: *const ::std::os::raw::c_void,
        srcsize: i32,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Decompress a block of compressed data in @p src, put the result in\n @p dest and returns the size of the decompressed block.\n\n @warning The @p src buffer and the @p dest buffer can not overlap.\n\n @remark Decompression is memory safe and guaranteed not to write the @p dest\n buffer more than what is specified in @p destsize.\n\n @remark In case you want to keep under control the number of bytes read from\n source, you can call #blosc1_cbuffer_sizes first to check whether the\n @p nbytes (i.e. the number of bytes to be read from @p src buffer by this\n function) in the compressed buffer is ok with you.\n\n @param src The buffer to be decompressed.\n @param srcsize The size of the buffer to be decompressed.\n @param dest The buffer where the decompressed data will be put.\n @param destsize The size of the @p dest buffer.\n\n @return The number of bytes decompressed.\n If an error occurs, e.g. the compressed data is corrupted or the\n output buffer is not large enough, then a negative value\n will be returned instead."]
    pub fn blosc2_decompress(
        src: *const ::std::os::raw::c_void,
        srcsize: i32,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Context interface to Blosc compression. This does not require a call\n to #blosc2_init and can be called from multithreaded applications\n without the global lock being used, so allowing Blosc be executed\n simultaneously in those scenarios.\n\n @param context A blosc2_context struct with the different compression params.\n @param src The buffer containing the data to be compressed.\n @param srcsize The number of bytes to be compressed from the @p src buffer.\n @param dest The buffer where the compressed data will be put.\n @param destsize The size in bytes of the @p dest buffer.\n\n @return The number of bytes compressed.\n If @p src buffer cannot be compressed into @p destsize, the return\n value is zero and you should discard the contents of the @p dest\n buffer.  A negative return value means that an internal error happened.\n It could happen that context is not meant for compression (which is stated in stderr).\n Otherwise, please report it back together with the buffer data causing this\n and compression settings."]
    pub fn blosc2_compress_ctx(
        context: *mut blosc2_context,
        src: *const ::std::os::raw::c_void,
        srcsize: i32,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Context interface to Blosc decompression. This does not require a\n call to #blosc2_init and can be called from multithreaded\n applications without the global lock being used, so allowing Blosc\n be executed simultaneously in those scenarios.\n\n @param context The blosc2_context struct with the different compression params.\n @param src The buffer of compressed data.\n @param srcsize The length of buffer of compressed data.\n @param dest The buffer where the decompressed data will be put.\n @param destsize The size in bytes of the @p dest buffer.\n\n @warning The @p src buffer and the @p dest buffer can not overlap.\n\n @remark Decompression is memory safe and guaranteed not to write the @p dest\n buffer more than what is specified in @p destsize.\n\n @remark In case you want to keep under control the number of bytes read from\n source, you can call #blosc1_cbuffer_sizes first to check the @p nbytes\n (i.e. the number of bytes to be read from @p src buffer by this function)\n in the compressed buffer.\n\n @remark If #blosc2_set_maskout is called prior to this function, its\n @p block_maskout parameter will be honored for just *one single* shot;\n i.e. the maskout in context will be automatically reset to NULL, so\n mask won't be used next time (unless #blosc2_set_maskout is called again).\n\n @return The number of bytes decompressed (i.e. the maskout blocks are not\n counted). If an error occurs, e.g. the compressed data is corrupted,\n @p destsize is not large enough or context is not meant for decompression,\n then a negative value will be returned instead."]
    pub fn blosc2_decompress_ctx(
        context: *mut blosc2_context,
        src: *const ::std::os::raw::c_void,
        srcsize: i32,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a chunk made of zeros.\n\n @param cparams The compression parameters.\n @param nbytes The size (in bytes) of the chunk.\n @param dest The buffer where the data chunk will be put.\n @param destsize The size (in bytes) of the @p dest buffer;\n must be BLOSC_EXTENDED_HEADER_LENGTH at least.\n\n @return The number of bytes compressed (BLOSC_EXTENDED_HEADER_LENGTH).\n If negative, there has been an error and @p dest is unusable."]
    pub fn blosc2_chunk_zeros(
        cparams: blosc2_cparams,
        nbytes: i32,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a chunk made of nans.\n\n @param cparams The compression parameters;\n only 4 bytes (float) and 8 bytes (double) are supported.\n @param nbytes The size (in bytes) of the chunk.\n @param dest The buffer where the data chunk will be put.\n @param destsize The size (in bytes) of the @p dest buffer;\n must be BLOSC_EXTENDED_HEADER_LENGTH at least.\n\n @note Whether the NaNs are floats or doubles will be given by the typesize.\n\n @return The number of bytes compressed (BLOSC_EXTENDED_HEADER_LENGTH).\n If negative, there has been an error and @p dest is unusable."]
    pub fn blosc2_chunk_nans(
        cparams: blosc2_cparams,
        nbytes: i32,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a chunk made of repeated values.\n\n @param cparams The compression parameters.\n @param nbytes The size (in bytes) of the chunk.\n @param dest The buffer where the data chunk will be put.\n @param destsize The size (in bytes) of the @p dest buffer.\n @param repeatval A pointer to the repeated value (little endian).\n The size of the value is given by @p cparams.typesize param.\n\n @return The number of bytes compressed (BLOSC_EXTENDED_HEADER_LENGTH + typesize).\n If negative, there has been an error and @p dest is unusable."]
    pub fn blosc2_chunk_repeatval(
        cparams: blosc2_cparams,
        nbytes: i32,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
        repeatval: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a chunk made of uninitialized values.\n\n @param cparams The compression parameters.\n @param nbytes The size (in bytes) of the chunk.\n @param dest The buffer where the data chunk will be put.\n @param destsize The size (in bytes) of the @p dest buffer;\n must be BLOSC_EXTENDED_HEADER_LENGTH at least.\n\n @return The number of bytes compressed (BLOSC_EXTENDED_HEADER_LENGTH).\n If negative, there has been an error and @p dest is unusable."]
    pub fn blosc2_chunk_uninit(
        cparams: blosc2_cparams,
        nbytes: i32,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Context interface counterpart for #blosc1_getitem.\n\n @param context Context pointer.\n @param src The compressed buffer from data will be decompressed.\n @param srcsize Compressed buffer length.\n @param start The position of the first item (of @p typesize size) from where data\n will be retrieved.\n @param nitems The number of items (of @p typesize size) that will be retrieved.\n @param dest The buffer where the decompressed data retrieved will be put.\n @param destsize Output buffer length.\n\n @return The number of bytes copied to @p dest or a negative value if\n some error happens."]
    pub fn blosc2_getitem_ctx(
        context: *mut blosc2_context,
        src: *const ::std::os::raw::c_void,
        srcsize: i32,
        start: ::std::os::raw::c_int,
        nitems: ::std::os::raw::c_int,
        dest: *mut ::std::os::raw::c_void,
        destsize: i32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief This struct is meant for holding storage parameters for a\n for a blosc2 container, allowing to specify, for example, how to interpret\n the contents included in the schunk."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_storage {
    pub contiguous: bool,
    pub urlpath: *mut ::std::os::raw::c_char,
    pub cparams: *mut blosc2_cparams,
    pub dparams: *mut blosc2_dparams,
    pub io: *mut blosc2_io,
}
#[test]
fn bindgen_test_layout_blosc2_storage() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_storage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_storage>(),
        40usize,
        concat!("Size of: ", stringify!(blosc2_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_storage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contiguous) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_storage),
            "::",
            stringify!(contiguous)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).urlpath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_storage),
            "::",
            stringify!(urlpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cparams) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_storage),
            "::",
            stringify!(cparams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dparams) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_storage),
            "::",
            stringify!(dparams)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).io) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_storage),
            "::",
            stringify!(io)
        )
    );
}
impl Default for blosc2_storage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Default struct for #blosc2_storage meant for user initialization."]
    pub static BLOSC2_STORAGE_DEFAULTS: blosc2_storage;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_frame_s {
    _unused: [u8; 0],
}
pub type blosc2_frame = blosc2_frame_s;
#[doc = " @brief This struct is meant to store metadata information inside\n a #blosc2_schunk, allowing to specify, for example, how to interpret\n the contents included in the schunk."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_metalayer {
    #[doc = "!< The metalayer identifier for Blosc client (e.g. Blosc2 NDim)."]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "!< The serialized (msgpack preferably) content of the metalayer."]
    pub content: *mut u8,
    #[doc = "!< The length in bytes of the content."]
    pub content_len: i32,
}
#[test]
fn bindgen_test_layout_blosc2_metalayer() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_metalayer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_metalayer>(),
        24usize,
        concat!("Size of: ", stringify!(blosc2_metalayer))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_metalayer>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_metalayer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_metalayer),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_metalayer),
            "::",
            stringify!(content)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_metalayer),
            "::",
            stringify!(content_len)
        )
    );
}
impl Default for blosc2_metalayer {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief This struct is the standard container for Blosc 2 compressed data.\n\n This is essentially a container for Blosc 1 chunks of compressed data,\n and it allows to overcome the 32-bit limitation in Blosc 1. Optionally,\n a #blosc2_frame can be attached so as to store the compressed chunks contiguously."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_schunk {
    pub version: u8,
    pub compcode: u8,
    pub compcode_meta: u8,
    pub clevel: u8,
    pub splitmode: u8,
    pub typesize: i32,
    pub blocksize: i32,
    pub chunksize: i32,
    pub filters: [u8; 6usize],
    pub filters_meta: [u8; 6usize],
    pub nchunks: i64,
    pub current_nchunk: i64,
    pub nbytes: i64,
    pub cbytes: i64,
    pub data: *mut *mut u8,
    pub data_len: usize,
    pub storage: *mut blosc2_storage,
    pub frame: *mut blosc2_frame,
    pub cctx: *mut blosc2_context,
    pub dctx: *mut blosc2_context,
    pub metalayers: [*mut blosc2_metalayer; 16usize],
    pub nmetalayers: u16,
    pub vlmetalayers: [*mut blosc2_metalayer; 8192usize],
    pub nvlmetalayers: i16,
    pub udbtune: *mut blosc2_btune,
    pub ndim: i8,
    pub blockshape: *mut i64,
}
#[test]
fn bindgen_test_layout_blosc2_schunk() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_schunk> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_schunk>(),
        65816usize,
        concat!("Size of: ", stringify!(blosc2_schunk))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_schunk>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_schunk))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compcode) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(compcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compcode_meta) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(compcode_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clevel) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(clevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).splitmode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(splitmode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(typesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blocksize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(blocksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chunksize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(chunksize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filters) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filters_meta) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(filters_meta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nchunks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(nchunks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_nchunk) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(current_nchunk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nbytes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbytes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(cbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data_len) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(data_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).storage) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(storage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cctx) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(cctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dctx) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(dctx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).metalayers) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(metalayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nmetalayers) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(nmetalayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vlmetalayers) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(vlmetalayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nvlmetalayers) as usize - ptr as usize },
        65784usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(nvlmetalayers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udbtune) as usize - ptr as usize },
        65792usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(udbtune)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ndim) as usize - ptr as usize },
        65800usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(ndim)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockshape) as usize - ptr as usize },
        65808usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_schunk),
            "::",
            stringify!(blockshape)
        )
    );
}
impl Default for blosc2_schunk {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Create a new super-chunk.\n\n @param storage The storage properties.\n\n @remark In case that storage.urlpath is not NULL, the data is stored\n on-disk.  If the data file(s) exist, they are *overwritten*.\n\n @return The new super-chunk."]
    pub fn blosc2_schunk_new(storage: *mut blosc2_storage) -> *mut blosc2_schunk;
}
extern "C" {
    #[doc = " Create a copy of a super-chunk.\n\n @param schunk The super-chunk to be copied.\n @param storage The storage properties.\n\n @return The new super-chunk."]
    pub fn blosc2_schunk_copy(
        schunk: *mut blosc2_schunk,
        storage: *mut blosc2_storage,
    ) -> *mut blosc2_schunk;
}
extern "C" {
    #[doc = " @brief Create a super-chunk out of a contiguous frame buffer.\n\n @param cframe The buffer of the in-memory frame.\n @param copy Whether the super-chunk should make a copy of\n the @p cframe data or not.  The copy will be made to an internal\n sparse frame.\n\n @remark If copy is false, the @p cframe buffer passed will be owned\n by the super-chunk and will be automatically freed when\n blosc2_schunk_free() is called.  If the user frees it after the\n opening, bad things will happen.  Don't do that (or set @p copy).\n\n @param len The length of the buffer (in bytes).\n\n @return The new super-chunk."]
    pub fn blosc2_schunk_from_buffer(cframe: *mut u8, len: i64, copy: bool) -> *mut blosc2_schunk;
}
extern "C" {
    #[doc = " @brief Set the private `avoid_cframe_free` field in a frame.\n\n @param schunk The super-chunk referencing the frame.\n @param avoid_cframe_free The value to set in the blosc2_frame_s structure.\n\n @warning If you set it to `true` you will be responsible of freeing it."]
    pub fn blosc2_schunk_avoid_cframe_free(schunk: *mut blosc2_schunk, avoid_cframe_free: bool);
}
extern "C" {
    #[doc = " @brief Open an existing super-chunk that is on-disk (frame). No in-memory copy is made.\n\n @param urlpath The file name.\n\n @return The new super-chunk.  NULL if not found or not in frame format."]
    pub fn blosc2_schunk_open(urlpath: *const ::std::os::raw::c_char) -> *mut blosc2_schunk;
}
extern "C" {
    #[doc = " @brief Open an existing super-chunk that is on-disk (frame). No in-memory copy is made.\n\n @param urlpath The file name.\n\n @param offset The frame offset.\n\n @return The new super-chunk.  NULL if not found or not in frame format."]
    pub fn blosc2_schunk_open_offset(
        urlpath: *const ::std::os::raw::c_char,
        offset: i64,
    ) -> *mut blosc2_schunk;
}
extern "C" {
    #[doc = " @brief Open an existing super-chunk (no copy is made) using a user-defined I/O interface.\n\n @param urlpath The file name.\n\n @param udio The user-defined I/O interface.\n\n @return The new super-chunk."]
    pub fn blosc2_schunk_open_udio(
        urlpath: *const ::std::os::raw::c_char,
        udio: *const blosc2_io,
    ) -> *mut blosc2_schunk;
}
extern "C" {
    pub fn blosc2_schunk_to_buffer(
        schunk: *mut blosc2_schunk,
        cframe: *mut *mut u8,
        needs_free: *mut bool,
    ) -> i64;
}
extern "C" {
    pub fn blosc2_schunk_to_file(
        schunk: *mut blosc2_schunk,
        urlpath: *const ::std::os::raw::c_char,
    ) -> i64;
}
extern "C" {
    pub fn blosc2_schunk_append_file(
        schunk: *mut blosc2_schunk,
        urlpath: *const ::std::os::raw::c_char,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Release resources from a super-chunk.\n\n @param schunk The super-chunk to be freed.\n\n @remark All the memory resources attached to the super-frame are freed.\n If the super-chunk is on-disk, the data continues there for a later\n re-opening.\n\n @return 0 if success."]
    pub fn blosc2_schunk_free(schunk: *mut blosc2_schunk) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Append an existing @p chunk to a super-chunk.\n\n @param schunk The super-chunk where the chunk will be appended.\n @param chunk The @p chunk to append.  An internal copy is made, so @p chunk can be reused or\n freed if desired.\n @param copy Whether the chunk should be copied internally or can be used as-is.\n\n @return The number of chunks in super-chunk. If some problem is\n detected, this number will be negative."]
    pub fn blosc2_schunk_append_chunk(
        schunk: *mut blosc2_schunk,
        chunk: *mut u8,
        copy: bool,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Update a chunk at a specific position in a super-chunk.\n\n @param schunk The super-chunk where the chunk will be updated.\n @param nchunk The position where the chunk will be updated.\n @param chunk The new @p chunk. If an internal copy is made, the @p chunk can be reused or\n freed if desired.\n @param copy Whether the chunk should be copied internally or can be used as-is.\n\n @return The number of chunks in super-chunk. If some problem is\n detected, this number will be negative."]
    pub fn blosc2_schunk_update_chunk(
        schunk: *mut blosc2_schunk,
        nchunk: i64,
        chunk: *mut u8,
        copy: bool,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Insert a chunk at a specific position in a super-chunk.\n\n @param schunk The super-chunk where the chunk will be appended.\n @param nchunk The position where the chunk will be inserted.\n @param chunk The @p chunk to insert. If an internal copy is made, the @p chunk can be reused or\n freed if desired.\n @param copy Whether the chunk should be copied internally or can be used as-is.\n\n @return The number of chunks in super-chunk. If some problem is\n detected, this number will be negative."]
    pub fn blosc2_schunk_insert_chunk(
        schunk: *mut blosc2_schunk,
        nchunk: i64,
        chunk: *mut u8,
        copy: bool,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Delete a chunk at a specific position in a super-chunk.\n\n @param schunk The super-chunk where the chunk will be deleted.\n @param nchunk The position where the chunk will be deleted.\n\n @return The number of chunks in super-chunk. If some problem is\n detected, this number will be negative."]
    pub fn blosc2_schunk_delete_chunk(schunk: *mut blosc2_schunk, nchunk: i64) -> i64;
}
extern "C" {
    #[doc = " @brief Append a @p src data buffer to a super-chunk.\n\n @param schunk The super-chunk where data will be appended.\n @param src The buffer of data to compress.\n @param nbytes The size of the @p src buffer.\n\n @return The number of chunks in super-chunk. If some problem is\n detected, this number will be negative."]
    pub fn blosc2_schunk_append_buffer(
        schunk: *mut blosc2_schunk,
        src: *mut ::std::os::raw::c_void,
        nbytes: i32,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Decompress and return the @p nchunk chunk of a super-chunk.\n\n If the chunk is uncompressed successfully, it is put in the @p *dest\n pointer.\n\n @param schunk The super-chunk from where the chunk will be decompressed.\n @param nchunk The chunk to be decompressed (0 indexed).\n @param dest The buffer where the decompressed data will be put.\n @param nbytes The size of the area pointed by @p *dest.\n\n @warning You must make sure that you have space enough to store the\n uncompressed data.\n\n @return The size of the decompressed chunk or 0 if it is non-initialized. If some problem is\n detected, a negative code is returned instead."]
    pub fn blosc2_schunk_decompress_chunk(
        schunk: *mut blosc2_schunk,
        nchunk: i64,
        dest: *mut ::std::os::raw::c_void,
        nbytes: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return a compressed chunk that is part of a super-chunk in the @p chunk parameter.\n\n @param schunk The super-chunk from where to extract a chunk.\n @param nchunk The chunk to be extracted (0 indexed).\n @param chunk The pointer to the chunk of compressed data.\n @param needs_free The pointer to a boolean indicating if it is the user's\n responsibility to free the chunk returned or not.\n\n @warning If the super-chunk is backed by a frame that is disk-based, a buffer is allocated for the\n (compressed) chunk, and hence a free is needed.\n You can check whether the chunk requires a free with the @p needs_free parameter.\n If the chunk does not need a free, it means that a pointer to the location in the super-chunk\n (or the backing in-memory frame) is returned in the @p chunk parameter.\n\n @return The size of the (compressed) chunk or 0 if it is non-initialized. If some problem is\n detected, a negative code is returned instead."]
    pub fn blosc2_schunk_get_chunk(
        schunk: *mut blosc2_schunk,
        nchunk: i64,
        chunk: *mut *mut u8,
        needs_free: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return a (lazy) compressed chunk that is part of a super-chunk in the @p chunk parameter.\n\n @param schunk The super-chunk from where to extract a chunk.\n @param nchunk The chunk to be extracted (0 indexed).\n @param chunk The pointer to the (lazy) chunk of compressed data.\n @param needs_free The pointer to a boolean indicating if it is the user's\n responsibility to free the chunk returned or not.\n\n @note For disk-based frames, a lazy chunk is always returned.\n\n @warning Currently, a lazy chunk can only be used by #blosc2_decompress_ctx and #blosc2_getitem_ctx.\n\n @warning If the super-chunk is backed by a frame that is disk-based, a buffer is allocated for the\n (compressed) chunk, and hence a free is needed.\n You can check whether requires a free with the @p needs_free parameter.\n If the chunk does not need a free, it means that a pointer to the location in the super-chunk\n (or the backing in-memory frame) is returned in the @p chunk parameter.  In this case the returned\n chunk is not lazy.\n\n @return The size of the (compressed) chunk or 0 if it is non-initialized. If some problem is\n detected, a negative code is returned instead.  Note that a lazy chunk is somewhat larger than\n a regular chunk because of the trailer section (for details see `README_CHUNK_FORMAT.rst`)."]
    pub fn blosc2_schunk_get_lazychunk(
        schunk: *mut blosc2_schunk,
        nchunk: i64,
        chunk: *mut *mut u8,
        needs_free: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Fill buffer with a schunk slice.\n\n @param schunk The super-chunk from where to extract a slice.\n @param start Index (0-based) where the slice begins.\n @param stop The first index (0-based) that is not in the selected slice.\n @param buffer The buffer where the data will be stored.\n\n @warning You must make sure that you have space enough in buffer to store the\n uncompressed data.\n\n @return An error code."]
    pub fn blosc2_schunk_get_slice_buffer(
        schunk: *mut blosc2_schunk,
        start: i64,
        stop: i64,
        buffer: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Update a schunk slice from buffer.\n\n @param schunk The super-chunk where to set the slice.\n @param start Index (0-based) where the slice begins.\n @param stop The first index (0-based) that is not in the selected slice.\n @param buffer The buffer containing the data to set.\n\n\n @return An error code."]
    pub fn blosc2_schunk_set_slice_buffer(
        schunk: *mut blosc2_schunk,
        start: i64,
        stop: i64,
        buffer: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the @p cparams associated to a super-chunk.\n\n @param schunk The super-chunk from where to extract the compression parameters.\n @param cparams The pointer where the compression params will be returned.\n\n @warning A new struct is allocated, and the user should free it after use.\n\n @return 0 if succeeds. Else a negative code is returned."]
    pub fn blosc2_schunk_get_cparams(
        schunk: *mut blosc2_schunk,
        cparams: *mut *mut blosc2_cparams,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the @p dparams struct associated to a super-chunk.\n\n @param schunk The super-chunk from where to extract the decompression parameters.\n @param dparams The pointer where the decompression params will be returned.\n\n @warning A new struct is allocated, and the user should free it after use.\n\n @return 0 if succeeds. Else a negative code is returned."]
    pub fn blosc2_schunk_get_dparams(
        schunk: *mut blosc2_schunk,
        dparams: *mut *mut blosc2_dparams,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Reorder the chunk offsets of an existing super-chunk.\n\n @param schunk The super-chunk whose chunk offsets are to be reordered.\n @param offsets_order The new order of the chunk offsets.\n\n @return 0 if succeeds. Else a negative code is returned."]
    pub fn blosc2_schunk_reorder_offsets(
        schunk: *mut blosc2_schunk,
        offsets_order: *mut i64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the length (in bytes) of the internal frame of the super-chunk.\n\n @param schunk The super-chunk.\n\n @return The length (in bytes) of the internal frame.\n If there is not an internal frame, an estimate of the length is provided."]
    pub fn blosc2_schunk_frame_len(schunk: *mut blosc2_schunk) -> i64;
}
extern "C" {
    #[doc = " @brief Quickly fill an empty frame with special values (zeros, NaNs, uninit).\n\n @param schunk The super-chunk to be filled.  This must be empty initially.\n @param nitems The number of items to fill.\n @param special_value The special value to use for filling.  The only values\n supported for now are BLOSC2_SPECIAL_ZERO, BLOSC2_SPECIAL_NAN and BLOSC2_SPECIAL_UNINIT.\n @param chunksize The chunksize for the chunks that are to be added to the super-chunk.\n\n @return The total number of chunks that have been added to the super-chunk.\n If there is an error, a negative value is returned."]
    pub fn blosc2_schunk_fill_special(
        schunk: *mut blosc2_schunk,
        nitems: i64,
        special_value: ::std::os::raw::c_int,
        chunksize: i32,
    ) -> i64;
}
extern "C" {
    #[doc = " @brief Add content into a new metalayer.\n\n @param schunk The super-chunk to which the metalayer should be added.\n @param name The name of the metalayer.\n @param content The content of the metalayer.\n @param content_len The length of the content.\n\n @return If successful, the index of the new metalayer. Else, return a negative value."]
    pub fn blosc2_meta_add(
        schunk: *mut blosc2_schunk,
        name: *const ::std::os::raw::c_char,
        content: *mut u8,
        content_len: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Update the content of an existing metalayer.\n\n @param schunk The frame containing the metalayer.\n @param name The name of the metalayer to be updated.\n @param content The new content of the metalayer.\n @param content_len The length of the content.\n\n @note Contrarily to #blosc2_meta_add the updates to metalayers\n are automatically serialized into a possible attached frame.\n\n @return If successful, the index of the metalayer. Else, return a negative value."]
    pub fn blosc2_meta_update(
        schunk: *mut blosc2_schunk,
        name: *const ::std::os::raw::c_char,
        content: *mut u8,
        content_len: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Find whether the schunk has a variable-length metalayer or not.\n\n @param schunk The super-chunk from which the variable-length metalayer will be checked.\n @param name The name of the variable-length metalayer to be checked.\n\n @return If successful, return the index of the variable-length metalayer. Else, return a negative value."]
    pub fn blosc2_vlmeta_exists(
        schunk: *mut blosc2_schunk,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add content into a new variable-length metalayer.\n\n @param schunk The super-chunk to which the variable-length metalayer should be added.\n @param name The name of the variable-length metalayer.\n @param content The content to be added.\n @param content_len The length of the content.\n @param cparams The parameters for compressing the variable-length metalayer content. If NULL,\n the `BLOSC2_CPARAMS_DEFAULTS` will be used.\n\n @return If successful, the index of the new variable-length metalayer. Else, return a negative value."]
    pub fn blosc2_vlmeta_add(
        schunk: *mut blosc2_schunk,
        name: *const ::std::os::raw::c_char,
        content: *mut u8,
        content_len: i32,
        cparams: *mut blosc2_cparams,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Update the content of an existing variable-length metalayer.\n\n @param schunk The super-chunk containing the variable-length metalayer.\n @param name The name of the variable-length metalayer to be updated.\n @param content The new content of the variable-length metalayer.\n @param content_len The length of the content.\n @param cparams The parameters for compressing the variable-length metalayer content. If NULL,\n the `BLOSC2_CPARAMS_DEFAULTS` will be used.\n\n @return If successful, the index of the variable-length metalayer. Else, return a negative value."]
    pub fn blosc2_vlmeta_update(
        schunk: *mut blosc2_schunk,
        name: *const ::std::os::raw::c_char,
        content: *mut u8,
        content_len: i32,
        cparams: *mut blosc2_cparams,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the content out of a variable-length metalayer.\n\n @param schunk The super-chunk containing the variable-length metalayer.\n @param name The name of the variable-length metalayer.\n @param content The pointer where the content will be put.\n @param content_len The pointer where the length of the content will be put.\n\n @warning The @p **content receives a malloc'ed copy of the content.\n The user is responsible of freeing it.\n\n @return If successful, the index of the new variable-length metalayer. Else, return a negative value."]
    pub fn blosc2_vlmeta_get(
        schunk: *mut blosc2_schunk,
        name: *const ::std::os::raw::c_char,
        content: *mut *mut u8,
        content_len: *mut i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Delete the variable-length metalayer from the super-chunk.\n\n @param schunk The super-chunk containing the variable-length metalayer.\n @param name The name of the variable-length metalayer.\n\n @return If successful, the number of the variable-length metalayers in the super-chunk. Else, return a negative value."]
    pub fn blosc2_vlmeta_delete(
        schunk: *mut blosc2_schunk,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get a list of all the variable-length metalayer names.\n\n @param schunk The super-chunk containing the variable-length metalayers.\n @param names The pointer to a char** to store the name pointers. This should\n be of size *schunk->nvlmetalayers * sizeof(char*).\n\n @return The number of the variable-length metalayers in the super-chunk.\n This cannot fail unless the user does not pass a @p names which is large enough to\n keep pointers to all names, in which case funny things (seg faults and such) will happen."]
    pub fn blosc2_vlmeta_get_names(
        schunk: *mut blosc2_schunk,
        names: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc_set_timestamp(timestamp: *mut timespec);
}
extern "C" {
    pub fn blosc_elapsed_nsecs(start_time: timespec, end_time: timespec) -> f64;
}
extern "C" {
    pub fn blosc_elapsed_secs(start_time: timespec, end_time: timespec) -> f64;
}
extern "C" {
    #[doc = " @brief Get the internal blocksize to be used during compression. 0 means\n that an automatic blocksize is computed internally.\n\n @return The size in bytes of the internal block size."]
    pub fn blosc1_get_blocksize() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Force the use of a specific blocksize. If 0, an automatic\n blocksize will be used (the default).\n\n @warning The blocksize is a critical parameter with important\n restrictions in the allowed values, so use this with care."]
    pub fn blosc1_set_blocksize(blocksize: usize);
}
extern "C" {
    #[doc = " @brief Set the split mode.\n\n @param splitmode It can take the next values:\n  BLOSC_FORWARD_COMPAT_SPLIT\n  BLOSC_AUTO_SPLIT\n  BLOSC_NEVER_SPLIT\n  BLOSC_ALWAYS_SPLIT\n\n BLOSC_FORWARD_COMPAT offers reasonably forward compatibility,\n BLOSC_AUTO_SPLIT is for nearly optimal results (based on heuristics),\n BLOSC_NEVER_SPLIT and BLOSC_ALWAYS_SPLIT are for the user experimenting\n  when trying to get best compression ratios and/or speed.\n\n If not called, the default mode is BLOSC_FORWARD_COMPAT_SPLIT.\n\n This function should always succeed."]
    pub fn blosc1_set_splitmode(splitmode: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " @brief Get the offsets of a frame in a super-chunk.\n\n @param schunk The super-chunk containing the frame.\n\n @return If successful, return a pointer to a buffer of the decompressed offsets.\n The number of offsets is equal to schunk->nchunks; the user is\n responsible to free this buffer. Else, return a NULL value."]
    pub fn blosc2_frame_get_offsets(schunk: *mut blosc2_schunk) -> *mut i64;
}
#[doc = "Structures and functions related with compression codecs."]
pub type blosc2_codec_encoder_cb = ::std::option::Option<
    unsafe extern "C" fn(
        input: *const u8,
        input_len: i32,
        output: *mut u8,
        output_len: i32,
        meta: u8,
        cparams: *mut blosc2_cparams,
        chunk: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type blosc2_codec_decoder_cb = ::std::option::Option<
    unsafe extern "C" fn(
        input: *const u8,
        input_len: i32,
        output: *mut u8,
        output_len: i32,
        meta: u8,
        dparams: *mut blosc2_dparams,
        chunk: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blosc2_codec {
    pub compcode: u8,
    pub compname: *mut ::std::os::raw::c_char,
    pub complib: u8,
    pub compver: u8,
    pub encoder: blosc2_codec_encoder_cb,
    pub decoder: blosc2_codec_decoder_cb,
}
#[test]
fn bindgen_test_layout_blosc2_codec() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_codec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_codec>(),
        40usize,
        concat!("Size of: ", stringify!(blosc2_codec))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_codec>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_codec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compcode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_codec),
            "::",
            stringify!(compcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_codec),
            "::",
            stringify!(compname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).complib) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_codec),
            "::",
            stringify!(complib)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compver) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_codec),
            "::",
            stringify!(compver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoder) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_codec),
            "::",
            stringify!(encoder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoder) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_codec),
            "::",
            stringify!(decoder)
        )
    );
}
impl Default for blosc2_codec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief Register locally a user-defined codec in Blosc.\n\n @param codec The codec to register.\n\n @return 0 if succeeds. Else a negative code is returned."]
    pub fn blosc2_register_codec(codec: *mut blosc2_codec) -> ::std::os::raw::c_int;
}
#[doc = "Structures and functions related with filters plugins."]
pub type blosc2_filter_forward_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const u8,
        arg2: *mut u8,
        arg3: i32,
        arg4: u8,
        arg5: *mut blosc2_cparams,
        arg6: u8,
    ) -> ::std::os::raw::c_int,
>;
pub type blosc2_filter_backward_cb = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const u8,
        arg2: *mut u8,
        arg3: i32,
        arg4: u8,
        arg5: *mut blosc2_dparams,
        arg6: u8,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " @brief The parameters for a user-defined filter."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct blosc2_filter {
    pub id: u8,
    pub forward: blosc2_filter_forward_cb,
    pub backward: blosc2_filter_backward_cb,
}
#[test]
fn bindgen_test_layout_blosc2_filter() {
    const UNINIT: ::std::mem::MaybeUninit<blosc2_filter> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<blosc2_filter>(),
        24usize,
        concat!("Size of: ", stringify!(blosc2_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<blosc2_filter>(),
        8usize,
        concat!("Alignment of ", stringify!(blosc2_filter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_filter),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forward) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_filter),
            "::",
            stringify!(forward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backward) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(blosc2_filter),
            "::",
            stringify!(backward)
        )
    );
}
extern "C" {
    #[doc = " @brief Register locally a user-defined filter in Blosc.\n\n @param filter The filter to register.\n\n @return 0 if succeeds. Else a negative code is returned."]
    pub fn blosc2_register_filter(filter: *mut blosc2_filter) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc2_remove_dir(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc2_remove_urlpath(path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc2_rename_urlpath(
        old_urlpath: *mut ::std::os::raw::c_char,
        new_path: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn blosc2_unidim_to_multidim(ndim: u8, shape: *mut i64, i: i64, index: *mut i64);
}
extern "C" {
    pub fn blosc2_multidim_to_unidim(index: *const i64, ndim: i8, strides: *const i64, i: *mut i64);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
